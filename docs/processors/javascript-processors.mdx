---
title: 'JavaScript Processors (deprecated)'
sidebar_position: 2
---

:::note
This processor has been deprecated in the favor of the new `custom.javascript`.
:::

JavaScript processors make it possible to write custom processors in JavaScript. The API name for JavaScript processors
(used in the request to create a processor) is `js`. There's only one configuration parameter, `script`, which is the
script itself. To find out what's possible with the JS processors, also refer to the documentation for [goja](https://github.com/dop251/goja),
which is the JavaScript engine we use.

Here's an example of a request payload to create a JavaScript processor:

```json
{
  "type": "js",
  "parent": {
    "type": "TYPE_CONNECTOR",
    "id": "d1ae72ea-9d9c-4bb2-b993-fdb7a01825ab"
  },
  "config": {
    "settings": {
      "script": "function process(record) {\n    record.Metadata[\"foo-key\"] = \"foo-value\";\n    return record;\n}\n"
    }
  }
}
```
The above will create a JavaScript processor (`"type": "js"`), attached to a connector (for the parent, we have
`"type": "TYPE_CONNECTOR"`). The script used is:
```javascript
function process(record) {
    record.Metadata["foo-key"] = "foo-value";
    return record;
}
```

The script needs to define a function called `process`, which accepts an `sdk.Record`, and returns:
* an `sdk.Record`, in case you want to transform the record,
* `null`, in case you want to drop the record from the pipeline.

The above example request transforms a record, by "enriching" its metadata (it adds a metadata key). Following is an
example where we also filter records:
```javascript
function process(r) {
    // if the record metadata has a "keepme" key set
   // we will keep it.
   // otherwise we return null (i.e. we drop the record from the pipeline)
    if (r.Metadata["keepme"] != undefined) {
        return r
    }
    return null;
}
```

The script is not constrained to having only this function, i.e. you can have something like this:
```javascript
function doSomething(record) {
    // do something with the record
    return record
}

function process(record) {
    doSomething(record)
    return record
}
```

Conduit also provides a number of helper objects and methods which can be used in the JS code. Those are, currently:
1. `logger` - a `zerolog.Logger` which writes to the Conduit server logs. You can use it in the same way you would use
it in Go code, i.e. you can write this for example: `logger.Info().Msgf("hello, %v!", "world")`
2. `Record()` - constructs a `record.Record`.
3. `RawData()` - constructs `record.RawData`.
4. `StructuredData()` - constructs `record.StructuredData`.

Following is an example of a JavaScript processor, where we transform a record and utilize a number of tools mentioned
above:
```javascript
// Parses the record payload as JSON
function parseAsJSON(record) {
    // we can use all of the JavaScript built-in functions
    // we use the record as if we would use it Go code,
    // so record.Payload.Bytes() gives us the payload bytes
    return JSON.parse(String.fromCharCode.apply(String, record.Payload.Bytes()))
}

function process(record) {
    logger.Info().Msg("entering process");

    let json = parseAsJSON(record);
    json["greeting"] = "hello!";
    logger.Info().Msgf("json: %v", json);

    // we're creating a new RawData object, using a helper
    record.Payload.After = new RawData();
    record.Payload.After.Raw = JSON.stringify(json);

    logger.Info().Msg("exiting process");
    return record;
}
```
