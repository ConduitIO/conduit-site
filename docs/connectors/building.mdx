---
title: "Building Connectors"
sidebar_position: 5
---

## Developing Custom Connectors

Conduit offers extensibility through the development of connectors, which can be written in any programming language that supports [gRPC](https://grpc.io/). For ease of development, a Go-based [Connector SDK](https://github.com/ConduitIO/conduit-connector-sdk) is provided and its use is the recommended approach for creating Conduit connectors.

## Initializing a Conduit Connector Project

To begin the development of a custom Conduit connector, developers should initialize their project using the [Conduit connector template](https://github.com/ConduitIO/conduit-connector-template). This template streamlines the setup process by providing a fundamental project structure, along with utility configurations for GitHub actions and a Makefile.

Included in the Conduit Connector Template are:

- Base code for configuring the connector's source and destination.
- Sample unit tests to validate connector functionality.
- A preconfigured Makefile to assist with common build tasks.
- GitHub Actions Workflows for continuous integration including building, testing, linting, and automated release creation upon tag push.
- Dependabot configurations to automate dependency updates and minor version auto-merging.
- Issue and Pull Request templates for consistent contribution practices.
- A README template to guide project documentation.

### Steps to Use the Connector Template

1. On the repository's main page, select "Use this template".
2. Provide the new repository details as prompted.
3. Upon repository creation, clone it to your local development environment.
4. Execute the `./setup.sh` script with the desired module name, e.g., `./setup.sh github.com/awesome-org/conduit-connector-file`.
5. (Optional) Define code owners in the `CODEOWNERS` file.

## Connector Development Lifecycle

A Conduit Connector can serve as a source, destination, or both. Implement a source connector by defining a struct that satisfies the [sdk.Source](<https://pkg.go.dev/github.com/conduitio/conduit-connector-sdk#Source>) interface, or create a destination connector by creating a struct that satisfies [sdk.Destination](<https://pkg.go.dev/github.com/conduitio/conduit-connector-sdk#Destination>).

### Connector Component Files

#### `spec.go`

This file defines the public-facing characteristics of the connector such as its name and capabilities. Begin by updating placeholder values with the specific details of your connector.

```go
var version = "v0.1.0"

// Specification returns the connector's specification.
func Specification() sdk.Specification {
 return sdk.Specification{
  Name:        "file-sync",
  Summary:     "<describe your connector>",
  Description: "<describe your connector in detail>",
  Version:     version,
  Author:      "<your name>",
 }
}
```

#### `config.go`

This file holds configuration parameters shared between source and destination, if applicable. If separate configuration is required for source and destination, distinct `config.go` files should be created for each.

```go
type Config struct {
 // Directory is the file path to the directory that will be watched for file changes
 Directory string `json:"directory" validate:"required,regex=^(/[^/ ]*)+/?$"`
}
```

#### `paramgen_src.go` and `paramgen_dst.go`

These files are created using the [paramgen](https://github.com/ConduitIO/conduit-connector-sdk/tree/main/cmd/paramgen) tool, which generates code from the Config struct to provide a map of configuration parameters.

An example usage of the `paramgen` tool to generate a new map after updating a config struct is as follows:

```paramgen -path=./source -output=paramgen_src.go SourceConfig```

```go
// paramgen_src
func (SourceConfig) Parameters() map[string]sdk.Parameter {
 return map[string]sdk.Parameter{
  "directory": {
   Default:     "",
   Description: "directory is the file path to the directory that will be watched for file changes directory string `json:\"directory\" validate:\"required,regex=^(/[^/ ]*)+/?$\"`",
   Type:        sdk.ParameterTypeString,
   Validations: []sdk.Validation{},
  },
 }
}
```

```go
// paramgen_dst
func (DestinationConfig) Parameters() map[string]sdk.Parameter {
 return map[string]sdk.Parameter{
  "directory": {
   Default:     "",
   Description: "directory is the file path to the directory that will be watched for file changes directory string `json:\"directory\" validate:\"required,regex=^(/[^/ ]*)+/?$\"`",
   Type:        sdk.ParameterTypeString,
   Validations: []sdk.Validation{},
  },
 }
}

```

We recommend adding a `go:generate` comment which runs paramgen at the top of the Connector file

```go
package filesync

//go:generate paramgen -output=paramgen_src.go SourceConfig

...rest of Source connector code
```

```go
package filesync

//go:generate paramgen -output=paramgen_dest.go DestinationConfig

...rest of Destination connector code
```

#### `source.go` and `destination.go`

Define the principal operation logic of your connector within these files. Both types of connectors must handle configuration, establish connections, perform read/write operations, and properly close connections upon completion. Auxiliary functions for the configuration lifecycle are provided by the template.

- **`Parameters()`**: A map of named Parameters that describe how to configure the connector. This map is typically generate using `paramgen`

```go
func (s *Source) Parameters() map[string]sdk.Parameter {
 return s.config.Parameters()
}

```

- **`Configure()`**: Validates and stores configuration data for the connector. Any complex validation logic should be implemented here.

```go
func (s *Source) Configure(ctx context.Context, cfg map[string]string) error {
 sdk.Logger(ctx).Info().Msg("Configuring Source...")
 err := sdk.Util.ParseConfig(cfg, &s.config)
 if err != nil {
  return fmt.Errorf("invalid config: %w", err)
 }
 return nil
}
```

- **`Open()`**: Prepares the connector to start producing records based on the last known successful position. If needed, the connector should open connections in this function.

```go
func (s *Source) Open(ctx context.Context, pos sdk.Position) error {
 configDirPath := s.config.Directory
 files, err := ioutil.ReadDir(configDirPath)
 if err != nil {
  return fmt.Errorf("error reading directory '%s': %w", configDirPath, err)
 }

 for _, f := range files {
  sdk.Logger(ctx).Info().Msgf(" - %s\n", f.Name())
 }

 w, err := fsnotify.NewWatcher()
 if err != nil {
  return fmt.Errorf("error creating fsnotify watcher: %w", err)
 }
 s.watcher = w

 s.createCooldown = 2 * time.Second
 return s.watcher.Add(s.config.Directory)
}
```

- **`Read()`**: (a Source only function)
Gathers data from the configured data source and formats it into a `sdk.Record` that is returned from the function. The returned `sdk.Record` is queued into the pipeline to be consumed by a Destination connector.

```go
func (s *Source) Read(ctx context.Context) (sdk.Record, error) {
 for {
  select {
  case event, ok := <-s.watcher.Events:
   if !ok {
    return sdk.Record{}, fmt.Errorf("events channel was closed")
   }

   if event.Op&fsnotify.Create == fsnotify.Create {
    sdk.Logger(ctx).Info().Msgf("Detected new file: %s", event.Name)

    // Mark the file as recently created to avoid processing if it is modified shortly after being created
    s.markAsRecentlyCreated(event.Name)

    // Read the newly created file
    fileContent, err := ioutil.ReadFile(event.Name)
    if err != nil {
     return sdk.Record{}, err
    }

    recordKey := sdk.RawData(filepath.Base(event.Name))
    recordValue := sdk.RawData(fileContent)

    // Return a Record reflecting that a new file has been created
    return sdk.Util.Source.NewRecordCreate(
     sdk.Position(recordKey),
     map[string]string{
      MetadataFilePath: event.Name,
     },
     recordKey,
     recordValue,
    ), nil
   }

   // If the event is not a Create event, continue listening without doing anything
   continue

  case err, ok := <-s.watcher.Errors:
   if !ok {
    return sdk.Record{}, fmt.Errorf("errors channel was closed")
   }
   return sdk.Record{}, fmt.Errorf("error on watcher: %w", err)

  case <-ctx.Done():
   return sdk.Record{}, ctx.Err()
  }
 }
}
```

- **`Write()`**: (Destination connectors only) Writes records received from the Conduit pipeline directly to the destination.

```go
func (d *Destination) Write(ctx context.Context, recs []sdk.Record) (int, error) {
 outputDir := d.config.Directory

 for i, r := range recs {
  fileName, ok := r.Key.(sdk.RawData)
  if !ok || len(fileName) == 0 {
   return i, fmt.Errorf("record key is invalid or not provided, record index: %v", i)
  }

  filePath := filepath.Join(outputDir, string(fileName))
  if err := d.writeToFile(filePath, r.Payload.After.Bytes()); err != nil {
   return i, fmt.Errorf("failed to write record to file '%s', record index: %v, error: %w", filePath, i, err)
  }
  sdk.Logger(ctx).Info().Msgf("Wrote file %s to directory %s\n", string(fileName), outputDir)
 }
 return len(recs), nil
}
```

- **`Teardown()`**: Teardown signals to the connector that there will be no more calls to any other function. Any connections that were created in the `Open()` function should be closed here.

```go
func (s *Source) Teardown(ctx context.Context) error {

 if s.watcher != nil {
  err := s.watcher.Close()
  if err != nil {
   // Log the error or handle it as needed
   sdk.Logger(ctx).Error().Msgf("Failed to close fsnotify watcher: %v", err)
   return fmt.Errorf("failed to close fsnotify watcher: %w", err)
  }
 }
 return nil
}
```

### Building and Launching the Connector

Utilize the included `Makefile` for compiling a binary of your connector:

```bash
make build

```

Place the resulting binary file in Conduit's `connectors` directory. Run Conduit with:

```bash
./conduit

```

Access the Conduit UI at `http://localhost:8080/ui` to manage and observe your custom connector within the available connectors list.


## Supported data types

There are no limitations when it comes to data types a source connector can read
from a source. However, if a standalone source connector uses `record.StructuredData`
in its key or any part of the payload, then there are certain limitations in the
data types it can send to Conduit.

The following data types are supported:
* `bool`
* `int`, `int32`, `int64`, `uint`, `uint32`, `uint64`
* `float32`, `float64`
* `string`
* `[]byte` (stored as a string, base64-encoded)
* `map[string]interface{}` (a map of strings to any of the values that are supported)
* `[]interface{}` (a slice of any value that is supported)

A notable limitation is timestamps, i.e. `time.Time` values are not supported.

One way to support other values is to encode source data to a `[]byte` (e.g. using
a JSON encoding) and then store the value as `record.RawData`.
